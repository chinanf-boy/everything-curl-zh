
# 热释光

TLS代表传输层安全性,是以前称为SSL的技术的名称.但是SSL这个术语并没有真正消失,所以现在TLS和SSL这两个术语经常可互换地用于描述相同的事情.

TLS是TCP"之上"的密码安全层,它基于强公钥密码和数字签名,对数据篡改进行证明并保证服务器的真实性.

## 密码

当卷曲连接到TLS服务器时,它协商如何说协议,并且协商涉及双方需要同意的几个参数和变量.其中一个参数是使用哪些密码算法,即所谓的密码.随着时间的推移,安全研究人员发现了现有密码的缺陷和弱点,随着时间的推移,它们逐渐被淘汰.

使用冗长的选项,`-v`您可以获得关于密码和TLS版本协商的信息.通过使用`--ciphers`选项,您可以更改在谈判中更喜欢什么密码,但请注意,这是一个功能强大的特性,它需要知识来知道如何使用方式,而不只是使情况变得更糟.

## 启用TLS

CURL支持许多协议的TLS版本.HTTP有HTTPS,FTP有FTPS,LDAP有LDAP,POP3有POP3S,IMAP有IMAPS和SMTP有SMTPS.

如果服务器端支持它,您可以使用卷曲使用这些协议的TLS版本.

有两种通用协议来处理TLS.其中之一是已经在第一次连接握手时使用TLS,而另一个是使用协议特定的指令"升级"从纯文本到TLS的连接.

使用curl,如果显式地在URL中指定协议的TLS版本(名称以"S"字符结尾的那个),curl将尝试从开始就与TLS连接,而如果要在URL中指定非TLS版本,则可以*通常*升级与TLS的连接`--ssl`选择权.

支持表是这样的:

| 清除      | TLS版本 | ——SSL |
| ------- | ----- | ----- |
| 超文本传输协议 | HTTPS | 不     |
| LDAP    | LDAP  | 不     |
| 文件传输协议  | FTPS  | **对** |
| POP3    | POP3S | **对** |
| IMAP    | IMAPS | **对** |
| SMTP    | 贴片机   | **对** |

协议*可以*做`--ssl`都赞成那种方法.使用`--ssl`意味着卷曲会*尝试*为了升级到TLS的连接,但是如果失败了,它将继续使用协议的纯文本版本的传输.使`--ssl`选项**要求**TLS继续,而不是`--ssl-reqd`如果CURL不能成功地协商TLS,将使传输失败.

为FTP传输需要TLS安全性:

```
curl --ssl-reqd ftp://ftp.example.com/file.txt
```

建议TLS用于您的FTP传输:

```
curl --ssl ftp://ftp.example.com/file.txt
```

直接与TLS(连接到HTTPS\://、LDAPS://、FTPS://等)意味着TLS是强制性的,如果没有协商TLS,curl将返回错误.

通过HTTPS获取文件:

```
curl https://www.example.com/
```

## SSL和TLS版本

SSL是在90年代中期发明的,此后就发展起来了.SSL版本2是互联网上使用的第一个广泛版本,但在很长一段时间以前,它被认为是不安全的.SSL版本3从那里接管,并且它也被认为不安全,足以使用.

TLS版本1是第一个"标准".RFC 2246发表1999.TLS 1.1在2006出炉,进一步提高了安全性,其次是TLS 1.2在2008.TLS 1.2成为TLS的黄金标准十年.

TLS 1.3(RFC 8446)于2018年8月由IETF确定并发布为标准.这是迄今为止最安全和最快的TLS版本.然而,新的软件、工具和库并不支持它.

CURL默认使用SSL/TLS的"安全版本".这意味着除非特别告知,否则它不会协商SSLv2或SSLv3,事实上,几个TLS库不再提供对这些协议的支持,因此在很多情况下,除非您认真努力,否则curl甚至不能说出那些协议版本.

| 选择权       | 使用          |
| --------- | ----------- |
| ——SSLV2   | SSL版本2      |
| ——SSLV3   | SSL版本3      |
| ——TLVS1   | TLS> =版本1   |
| --TLVS1.0 | TLS> =版本1   |
| --tlsv1.1 | TLS> =版本1.1 |
| --tlsv1.2 | TLS> =版本1.2 |
| --TLVS1.3 | TLS> =版本1.3 |

**注:**TLS 1.3版本只在选定的最近的开发版本的TLS库支持,需要一定的卷曲7.52.0或后.

## 验证服务器证书

如果你不能确定你正在与一个服务器进行通信,那么连接到服务器是不值得的.**对的**宿主.如果我们不知道,我们也可以和一个冒名顶替者谈话.*出现*成为我们认为的那个人.

为了检查它是否与正确的TLS服务器通信,curl使用一组本地存储的CA证书来验证服务器证书的签名.作为TLS握手的一部分,所有服务器都向客户机提供证书,并且所有使用TLS的公共服务器都从已建立的证书颁发机构获得证书.

在应用了一些密码魔法之后,curl知道服务器实际上是为curl用来连接到它的主机名获取证书的正确服务器.未能验证服务器的证书是TLS握手失败,而CURL退出时出错.

在极少数情况下,即使证书验证失败,您也可能决定仍然希望与TLS服务器通信.然后你接受这样一个事实:你的交流可能会受到中间人的攻击.你放下警卫`-k`或`--insecure`选择权.

## CA存储

CURL需要一个"CA存储",一个CA证书的集合,来验证它所讨论的TLS服务器.

如果构建curl是为了使用对您的平台来说是"本地"的TLS库,那么该库也可能使用本地CA存储.如果没有,则必须构建curl才能知道本地CA存储库在哪里,或者用户需要在调用curl时提供到CA存储库的路径.

您可以在TLS握手中指出一个特定的CA包.`--cacert`命令行选项.这个包需要用PEM格式.还可以设置环境变量`CURL_CA_BUNDLE`通向完整的道路.

### Windows上的CA存储

在不使用本机TLS库(Schannel)的窗口上构建的curl对于如何找到和使用CA存储具有额外的顺序.

CURL将在这些目录中搜索一个名为"CURL CA束.CRT"的CA证书文件,并按此顺序:

1.  应用程序目录
2.  当前工作目录
3.  Windows系统目录(例如`C:\windows\system32`)
4.  Windows目录(例如`C:\windows`)
5.  所有目录沿`%PATH%`

## 证书钉扎

TLS证书钉扎是验证用于签署服务器证书的公钥没有改变的一种方法.它被"钉住"了.

在协商TLS或SSL连接时,服务器会发送一个表示其身份的证书.从这个证书中提取一个公钥,如果它不完全匹配提供给这个选项的公钥,curl将在发送或接收任何数据之前中止连接.

您告诉curl要读取sha256值的文件名,或者直接在命令行中用"sha256//"前缀指定base64编码的散列.可以指定这样的一个或多个散列,用分号(;)分隔.

```
curl --pinnedpubkey "sha256//83d34tasd3rt..." https://example.com/
```

此特性不受所有TLS后端的支持.

## OCSP装订

这使用名为Certificate Status Request的TLS扩展来请求服务器在握手时从CA提供新的"证明",证明它返回的证书仍然有效.这是一种确保服务器证书没有被撤销的方法.

如果服务器不支持这个扩展,测试将失败,并且卷发返回错误.服务器不支持这一点还是太常见了.

请求握手使用状态请求如下:

```
curl --cert-status https://example.com/
```

此特性仅由OpenSSL、GNUTLS和NSS后端支持.

## 客户证书

TLS客户端证书是客户端加密地向服务器证明它们确实是正确的对等体的一种方式.使用客户端证书的命令行指定证书和相应的密钥,然后将它们传递给与服务器的TLS握手.

当这样做时,您需要将客户机证书已经存储在文件中,并且您应该以前通过不同的通道从正确的实例中获得它.

密钥通常由需要提供或得到交互提示的密码保护.

CURL提供选项,让您指定一个文件,该文件既是客户端证书,又是使用的私钥.`--cert`,或者可以独立地指定密钥文件.`--key`:

```
curl --cert mycert:mypassword https://example.com
curl --cert mycert:mypassword --key mykey https://example.com
```

对于一些TLS后端,您还可以使用不同的类型传递密钥和证书:

```
curl --cert mycert:mypassword --cert-type PEM \
     --key mykey --key-type PEM https://example.com
```

## TLS-AUTH

TBD

## 不同的TLS后端

TBD

## 多个TLS后端

TBD
