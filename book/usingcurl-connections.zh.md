# 连接

大多数curl使用的协议都讲了 TCP.使用 TCP, 客户端(如curl)必须首先找出, 要与之通信的主机的 IP 地址,然后连接到它."连接到它"意味着执行 TCP 协议握手.

对于普通命令行使用，下面是介绍在URL上的操作的详细内容，您可以忽略这些细节. 但有时你会发现自己想要调整细节…

## 名字解析技巧

### 编辑主机文件-hosts

你可能需要使用`curl http://example.com`来连接到本地服务器,而不是实际的远程服务器.

在 Linux 和 UNIX 系统上, 你可以通过编辑你的`hosts`文件(文件)`/etc/hosts`, 例如添加`127.0.0.1 example.com`将主机重定向到本地主机.然而,此编辑需要管理访问,并且它具有影响其他所有应用程序的缺点.

### 更改主机: header

这个`Host:`头 是 一个 HTTP客户端告诉HTTP服务器要什么服务的正常方式, 那是因为,一般, 一个HTTP服务器会提供相同的软件实例的不同名称.

因此,通过自定义修改`Host:`头, 您可以让服务器响应站点的内容,即使您实际上没有连接到该主机名.

例如在你的本地机器上,运行`www.example.com`主站点的测试实例.,你想要 cURL, 请求 index html:

```
curl -H "Host: www.example.com" http://localhost/
```

当设置`Host:`自定义头和使用 Cookie时, curl将提取自定义名称,并在匹配 cookie 发送时,使用它作为主机.

当这个`Host:`与 HTTPS 服务器通信时,并不够数. 若是HTTPS的情况,在 TLS 协议中会有一个单独的扩展字段称为 SNI(Server Name Indication),它允许客户端告诉服务器它想要与之通信的服务器的名称. cURL将只提取从给定URL发送的 SNI 名称.

### 为名称提供自定义 IP 地址

你知道比cURL的名称解析更好的地址吗? 那你可以给自己的cURL一个 IP 地址! 如果要重定向端口 80,来访问`example.com`替代你的本地主机:

```
curl --resolve example.com:80:127.0.0.1 http://example.com/
```

您甚至可以指定多个`--resolve`, 以切换提供这种类型的多个重定向, 如果使用的 URL 有使用 HTTP 重定向,或者仅希望命令行使用多个 URL 时,可以使用这些重定向.

`--resolve`会将地址插入到 curl 的 DNS 缓存中,因此它能有效地,让 curl 相信这是解析名称时获得的地址.

当谈论 HTTPS 时,它将发送 URL 中的名称的 SNI,curl 将验证服务器的响应,以确保它提供于 URL 中的名称服务.

### 提供替换名称

作为`--resolve`选项的一个近亲,`--connect-to`选项提供了微小的变化.当使用特定的名称和端口号连接时,在引擎盖下, 它允许您指定替换 curl 使用的名称和端口号.

例如,假设有一个站点被调用`www.example.com`, 但这实际上是由三个不同的独立 HTTP 服务器:Load 1、Load 2 和 Load 3 提供, 用于负载均衡目的.在典型的正常过程中,curl 解析主站点,并访问负载均衡服务器之一(因为它返回一个列表,只选择其中的一个),一切都很好.如果您想将测试请求发送到,负载平衡集合之外的一个特定服务器(例如`load1.example.com`),你可以命令 curl 去做这件事.

你*可以*仍然使用`--resolve`,如果您知道 Load 1 的特定 IP 地址,就可以做到这一点.但是,若想不必解析和分别修复 IP 地址,可以直接告诉 curl:

```
curl --connect-to www.example.com:80:load1.example.com:80 http://www.example.com
```

它从 源名称+源端口 重定向到 目的地名称+目的地端口. cURL 将解决`load1.example.com`名称和连接,但在所有其他方式仍然假设它正在与`www.example.com`交谈.

###  c-ares 的名称解决方案

如本书中其他地方所详述的那样,cURL 可以用几种不同的名称解析后端来构建. 这些后端之一由 c-ares 库提供动力,当构建 curl 带有 c-ares 时,它获得一些额外的超级能力,而构建 curl 带有其他名称解析后端则不能.换句话说, 它获得了更具体地指示 DNS 服务器使用以及 DNS 如何流向网络的能力.

用`--dns-servers`您可以精确地指定, cURL 应该使用哪些 DNS 服务器 ,而不是默认的.这允许您运行自己的实验服务器,该服务器的回答不同,或者如果您的常规服务器不可靠或已死,则使用备份服务器.

用`--dns-ipv4-addr`和`--dns-ipv6-addr`您要求 curl 将 DNS 通信的本地端 "绑定" 到一个特定的 IP 地址和,`--dns-interface`您可以指示 curl 使用特定的网络接口来使用 DNS 请求.

这些`--dns-*`选项是非常先进的,只适用于那些知道自己在做什么的人,并理解这些选择. 总之它们提供非常可定制的 DNS 名称解析操作.

## 连接超时

curl 通常将 TCP 连接主机,作为其网络传输的初始部分.如果存在不稳定的网络条件或有故障的远程服务器,TCP 连接可能会失败或非常缓慢.

为了减少对脚本或其他使用的影响,可以设置允许连接尝试的 curl 的最大时间(以秒为单位).用`--connect-timeout`你告诉 curl 允许连接的最大时间,如果在那个时候 cURL 没有连接,它会返回一个故障.

连接超时仅限制了 curl 在连接时所花的时间,因此一旦建立了 TCP 连接,它可能需要更长的时间.见[超时](usingcurl-timeouts.zh.md)这个关于 cURL 超时的通用章节.

如果指定了低超时,则有效地禁用 curl 连接到通过不可靠网络访问的远程服务器、慢速服务器的能力.

连接超时可以指定为小数精度的十进制值.例如,允许 2781 毫秒连接:

```
curl --connect-timeout 2.781 https://example.com/
```

## 网络接口

在具有连接到多个网络的多个网络接口的机器上,存在这样的情况,您可以决定希望传出网络流量使用哪个网络接口.或者在通信中使用哪个源 IP 地址(来自多个 IP 地址).

告诉 curl 您希望将通信的本地端"绑定"到哪个网络接口、哪个 IP 地址或甚至主机名,以及`--interface`选项:

```
curl --interface eth1 https://www.example.com/

curl --interface 192.168.0.2 https://www.example.com/

curl --interface machine2 https://www.example.com/
```

## 本地端口号

在本地端的 IP 地址和端口号, 与远程端的 IP 地址和端口号之间创建 TCP 连接.远程端口号可以在 URL 中指定,通常有助于标识您正在瞄准的服务.

本地端口号通常由网络堆栈随机分配给 TCP 连接,您通常不必再考虑它.但是,在某些情况下,您会发现自己处于网络设备、防火墙或类似的设置后面,这些设置限制了哪些源端口号可以被允许传出连接.

对于这样的情况,您可以指定 curl 应将哪些本地端口绑定到连接.您可以指定要使用的单个端口号,或者指定端口的范围.我们建议使用一个范围,因为端口是稀缺资源,而您想要的确切资源可能已经在使用.如果您要求的本地端口号(或范围),cURL无法获得 ,它将以失败退出.

而且,在大多数操作系统中,如果不具有更高的特权级别(root),则无法绑定到 1024 以下的端口号, 并且如果可以避免,我们通常建议不要将 curl 作为 root 运行.

在获得此 HTTPS 页面时,请要求 curl 使用 4000 到 4200 之间的本地端口号:

```
curl --local-port 4000-4200 https://example.com/
```

## 保持活力

在不使用 TCP 连接的情况下,无论在哪个方向上,TCP 连接都是完全没有流量的.因此,无法将完全空闲的连接,与由于网络或服务器问题而完全过时的连接清楚地分开.

同时,现在许多网络设备,如防火墙或 NAT,都在跟踪 TCP 连接,以便它们能够转换地址,阻塞"错误的"传入数据包等. 这些设备通常将完全空闲的连接,计为N分钟后死连接，其中N在设备之间会有所变化,有时短至10分钟甚至更短.

避免真正缓慢的连接(或空闲的连接)被当作死连接和错误死连接的一种方法是确保TCP keep alive, `TCP keep alive` 是 TCP 协议中的一个特性,它使得 TCP 在完全空闲时来回发送"ping 帧". 当没有通信量移动到其上时, 它帮助空闲连接检测中断, 并且帮助中心系统不考虑连接死亡.

curl 默认使用 TCP KeePovior 作为这里提到的原因. 但有时你想*踹掉*活力,或者你想改变 TCP"Ping"之间的间隔(cURL 默认值为 60 秒).你可以关闭:

```
curl --no-keepalive https://example.com/
```

或将间隔改为 5 分钟(300 秒):

```
curl --keepalive-time 300 https://example.com/
```
